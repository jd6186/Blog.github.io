---
layout: post
title: "Python 성능관리 방법 vol.2 - 행렬연산 시 NumPy를 사용해야하는 이유"
tags: [BackEnd, Python, NumPy]
---

# Intro
안녕하세요 Noah입니다.<br/>
이번 포스팅에서는 Python 개발자들이 행렬연산 시 꼭 알아야 할 NumPy 사용 이유에 대해 다뤄보겠습니다.<br/> 
Python은 자동으로 메모리를 관리하는 편리한 언어이지만, 기본 설정만으로 모든 상황에서 최적의 성능을 낼 수는 없습니다.<br/>
특히, 대용량 데이터 처리에서는 인터프리터 언어의 한계 때문에 데이터 처리 속도가 느려질 수 있습니다.<br/>
이런 경우, NumPy와 같은 라이브러리를 활용하면 성능을 비약적으로 향상시킬 수 있습니다.<br/>

그럼, 시작해보겠습니다!
<br/><br/><br/><br/>

# 목차
1. [Intro](#intro)
2. [NumPy란 무엇인가?](#numpy란-무엇인가)
    - [1. 고정 크기의 데이터 타입 사용](#1-고정-크기의-데이터-타입-사용)
    - [2. 벡터화 연산 (Vectorized Operations)](#2-벡터화-연산-vectorized-operations)
        - [파이썬 루프가 느린 이유](#파이썬-루프가-느린-이유)
        - [비교: 파이썬 루프 vs NumPy 벡터화](#비교-파이썬-루프-vs-numpy-벡터화)
    - [3. C 기반 구현](#3-c-기반-구현)
    - [4. 브로드캐스팅 (Broadcasting)](#4-브로드캐스팅-broadcasting)
    - [5. 저수준 연산 최적화](#5-저수준-연산-최적화)
    - [6. 메모리 뷰와 슬라이싱](#6-메모리-뷰와-슬라이싱)
    - [7. 멀티스레딩 및 병렬 처리](#7-멀티스레딩-및-병렬-처리)
3. [Outro](#outro)

<br/><br/><br/><br/>

# NumPy란 무엇인가?
Python에서 NumPy를 사용하는 이유는 다음과 같은 특성 덕분에 메모리 효율적이고 고성능 데이터 처리가 가능하기 때문입니다.

## 1. **고정 크기의 데이터 타입 사용**
NumPy는 배열 내 모든 요소가 **동일한 데이터 타입**을 가지도록 강제합니다. 이는 다음과 같은 이점을 제공합니다<br/>
- **메모리 사용 효율**: 파이썬의 일반 리스트는 각 요소가 개별 객체로 저장되며, **객체 자체가 추가적인 메타데이터를 포함**하기 때문에 메모리를 더 많이 사용합니다.<br/>
  반면, NumPy 배열은 동일한 데이터 타입을 가진 요소를 **연속된 메모리 블록에 저장**하여 메모리를 절약합니다.
- **CPU 캐시 최적화**: 연속된 메모리 레이아웃은 CPU 캐시를 효과적으로 활용하여 접근 속도를 높입니다.
<br/><br/><br/>

## 2. **벡터화 연산 (Vectorized Operations)**
NumPy는 루프 없이도 배열의 모든 요소에 대해 연산을 수행할 수 있는 **벡터화 연산**을 지원합니다.<br/>
이 때문에 **파이썬 루프 대비 고성능**을 지원합니다. 파이썬의 for 루프는 인터프리터 수준에서 동작하기 때문에 느리지만, NumPy의 벡터화 연산은 **C 언어로 구현된 저수준 연산**을 활용하므로 훨씬 빠릅니다.

### 파이썬 루프가 느린 이유
- **인터프리터 수준 실행**: 파이썬은 코드를 실행할 때 각 명령어를 **한 줄씩 바이트코드로 변환 및 실행**하는 인터프리터 언어입니다. 루프의 각 반복마다 이러한 변환이 반복되며, 이는 성능을 저하시킵니다.
- **동적 타입 지정**: 파이썬은 동적 타입 언어이기 때문에 반복문 내 각 요소의 타입을 확인해야 하며, 타입 확인 비용이 추가로 발생합니다.
- **객체 기반 데이터 구조**: 파이썬 리스트의 각 요소는 **포인터와 메타데이터를 포함하는 객체**로 저장되므로, 추가적인 메모리 접근 비용과 관리 비용이 듭니다.
- **GIL(Global Interpreter Lock)**: 파이썬은 GIL로 인해 멀티스레드의 병렬 실행이 제한되며, 단일 코어에서 작업이 실행되기 때문에 고성능 작업에 제약이 생깁니다.

반면, NumPy의 벡터화 연산은 C로 구현된 최적화된 코드를 통해 **병렬적으로 데이터를 처리**하므로 성능이 크게 향상됩니다.

### 비교: 파이썬 루프 vs NumPy 벡터화
#### 파이썬 for 루프
각 요소를 순회하면서 연산하고, `append` 메서드를 호출하여 리스트에 추가합니다.<br/>
메모리 접근과 타입 확인, 메서드 호출 등의 오버헤드가 발생합니다.

```python
data = [1, 2, 3, 4, 5]
result = []
for x in data:
    result.append(x * 2)
```

#### NumPy 벡터화
한 줄의 연산으로 모든 요소를 처리하며, 내부적으로 C 언어로 최적화된 루프가 실행됩니다.<br/>
또한, 추가적인 메모리 오버헤드와 타입 검사가 없으므로 훨씬 빠릅니다.

```python
import numpy as np
data = np.array([1, 2, 3, 4, 5])
result = data * 2
```
<br/><br/><br/>

## 3. **C 기반 구현**
NumPy는 핵심 연산이 **C로 구현**되어 있습니다. 이로 인해 다음과 같은 장점이 있습니다.<br/>
- 파이썬의 동적 타이핑보다 훨씬 빠른 정적 타이핑 연산을 수행
- 저수준 연산에서 반복문을 제거하여 오버헤드를 줄임
- 다차원 배열 연산도 효율적으로 수행
<br/><br/><br/>

## 4. **브로드캐스팅 (Broadcasting)**
NumPy는 배열 크기가 다르더라도 특정 규칙에 따라 연산을 수행할 수 있는 **브로드캐스팅**을 지원합니다.<br/>
이로 인해 불필요한 복사를 줄이고 메모리 사용량을 절감할 수 있습니다.

```python
a = np.array([1, 2, 3])
b = 2
c = a + b  # b가 [2, 2, 2]로 확장된 것처럼 연산
```
<br/><br/><br/>

## 5. **저수준 연산 최적화**
NumPy는 BLAS와 LAPACK 같은 **고성능 수치 연산 라이브러리**를 내부적으로 사용합니다.<br/>
이로 인해 선형 대수 연산이나 행렬 연산 같은 복잡한 작업도 매우 빠르게 처리할 수 있습니다.
<br/><br/><br/>

## 6. **메모리 뷰와 슬라이싱**
NumPy는 배열의 **메모리 뷰**를 생성하여 데이터 복사를 최소화합니다.<br/>
파이썬 리스트에서는 슬라이싱 시 복사본이 생성되지만, NumPy 배열은 동일한 데이터의 뷰를 반환하여 메모리를 절약합니다.

```python
a = np.array([1, 2, 3, 4, 5])
b = a[2:4]  # 원본 데이터의 뷰
b[0] = 99   # 원본에도 영향을 미침
print(a)  # [ 1  2 99  4  5]
```
<br/><br/><br/>

## 7. **멀티스레딩 및 병렬 처리**
NumPy는 내부적으로 멀티스레딩을 활용하여 병렬로 연산을 수행합니다. 따라서 대규모 데이터셋 처리 시 성능이 더욱 향상됩니다.
<br/><br/><br/><br/>

# Outro
NumPy는 고정 크기의 데이터 타입, 벡터화 연산, C 기반 구현, 브로드캐스팅, 메모리 효율적인 슬라이싱 및 병렬 처리와 같은 특징 덕분에 메모리 효율적이며 고성능 데이터 처리가 가능합니다.<br/>
이로 인해 NumPy는 데이터 분석, 과학 계산, 머신러닝 등에서 필수적인 도구로 자리 잡았습니다. 여러분도 NumPy를 활용하여 Python의 성능을 향상시켜보세요!<br/>

다음 포스팅에서는 Python 성능 관리 방법의 세번째 주제를 다룰 예정이니, 많은 관심 부탁드립니다!

긴 글 읽어주셔서 감사합니다. 😊
