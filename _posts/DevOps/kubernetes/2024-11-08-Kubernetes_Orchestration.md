---
layout: post
title: "[AWS] ECS와 Kubernetes 비교에 대한 간단한 글(Kubernetes Orchestration 구성편)"
tags: [AWS, ECS, Kubernetes, DevOps]
---

# Intro
안녕하세요, Noah입니다.<br/>
오늘은 **쿠버네티스로 오케스트레이션을 구현하는 방법**에 대해 A부터 Z까지 전반적인 내용을 다루겠습니다.<br/>
또한, 오케스트레이션을 구현할 때 주의해야 할 사항들을 짚어보며, **어떤 서비스에서 ECS를, 어떤 서비스에서 쿠버네티스를 사용하는 것이 좋은지**에 대한 비교도 함께 살펴보겠습니다.<br/>
이번 글을 통해 쿠버네티스 오케스트레이션에 대한 이해도를 높이고, 각 상황에 맞는 오케스트레이션 도구 선택에 도움이 되기를 바랍니다.

그럼 시작해 보겠습니다.
<br/><br/><br/><br/>

# 목차
- [Intro](#intro)
- [쿠버네티스로 오케스트레이션 구현하기](#쿠버네티스로-오케스트레이션-구현하기)
    1. [오케스트레이션 구성 요소 및 단계](#1-오케스트레이션-구성-요소-및-단계)
    2. [쿠버네티스 오케스트레이션 구현 시 주의사항](#2-쿠버네티스-오케스트레이션-구현-시-주의사항)
    3. [ECS와 쿠버네티스 비교 및 선택 가이드](#3-ecs와-쿠버네티스-비교-및-선택-가이드)
- [Outro](#outro)
<br/><br/><br/><br/>

## 쿠버네티스로 오케스트레이션 구현하기
### 1. 오케스트레이션 구성 요소 및 단계
쿠버네티스로 오케스트레이션을 구현할 때는 기본적인 구성 요소와 실행 단계를 이해하는 것이 중요합니다.<br/>
쿠버네티스는 클러스터 내의 애플리케이션을 자동으로 배포하고 관리하며, 주로 **Pods, ReplicaSets, Deployments, Services**와 같은 리소스를 활용하여 오케스트레이션을 수행합니다.

**[구성 요소]**<br/>
- **Pod**: 쿠버네티스에서 가장 작은 배포 단위로, 애플리케이션 컨테이너가 포함됩니다. 일반적으로 하나의 포드는 하나의 컨테이너로 구성되지만, 여러 컨테이너가 하나의 포드 안에서 네트워크와 스토리지를 공유할 수도 있습니다.
- **ReplicaSet**: 특정 포드가 설정한 개수만큼 유지되도록 관리하는 역할을 합니다. 포드가 종료되거나 장애가 발생할 경우 새로운 포드를 자동으로 생성해 설정된 개수를 유지합니다.
- **Deployment**: ReplicaSet을 기반으로 애플리케이션을 배포하고 업데이트를 관리합니다. 예를 들어, 새 버전의 애플리케이션을 배포할 때 Rolling Update 방식으로 무중단 배포가 가능하게 합니다.
- **Service**: 클러스터 내에서 여러 포드에 접근할 수 있도록 하는 네트워크 엔드포인트를 제공합니다. Service는 로드 밸런서를 통해 외부 트래픽을 특정 포드에 연결할 수 있도록 해줍니다.

**[오케스트레이션 단계]**<br/>
1. **클러스터 설정 및 네임스페이스 생성**<br/>
   먼저, 쿠버네티스 클러스터를 설정하고 필요한 네임스페이스를 생성합니다. 네임스페이스는 여러 애플리케이션을 격리하여 관리할 수 있도록 해주는 역할을 합니다.<br/>
    ```bash
    kubectl create namespace my-app
    ```
2. **애플리케이션의 Deployment 작성 및 배포**<br/>
   Deployment YAML 파일을 작성하여 애플리케이션을 클러스터에 배포합니다. 배포 시 ReplicaSet을 통해 포드 개수를 정의할 수 있고, 롤링 업데이트 전략을 설정할 수 있습니다.<br/>
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: my-app-deployment
      namespace: my-app
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: my-app
      template:
        metadata:
          labels:
            app: my-app
        spec:
          containers:
          - name: my-app-container
            image: my-app:latest
            ports:
            - containerPort: 80
    ```
3. **서비스 설정**<br/>
   Service를 설정하여 클러스터 외부와 통신할 수 있도록 네트워크 엔드포인트를 제공합니다. 예를 들어, LoadBalancer 타입의 서비스는 외부에서 접근할 수 있는 퍼블릭 IP를 할당해 줍니다.<br/>
    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-service
      namespace: my-app
    spec:
      type: LoadBalancer
      selector:
        app: my-app
      ports:
      - protocol: TCP
        port: 80
        targetPort: 80
    ```
4. **모니터링 및 로그 설정**<br/>
   쿠버네티스 오케스트레이션의 마지막 단계로, 모니터링 도구(Prometheus, Grafana)와 로그 관리 도구(Fluentd, Elasticsearch)를 설정해 애플리케이션의 상태를 지속적으로 추적하고 로그 데이터를 중앙에서 관리합니다.<br/>
   이 과정을 통해 애플리케이션을 쉽게 배포하고, 포드 상태를 유지하며, 무중단으로 애플리케이션을 업데이트할 수 있는 오케스트레이션 환경을 구성할 수 있습니다.
<br/><br/>

### 2. 쿠버네티스 오케스트레이션 구현 시 주의사항
쿠버네티스를 사용하여 오케스트레이션을 구현할 때는 몇 가지 중요한 주의사항을 염두에 두어야 합니다.<br/>
이러한 주의사항들을 미리 설정해두면, 안정적인 쿠버네티스 오케스트레이션 환경을 구축할 수 있습니다.

- **리소스 제한 설정**: 쿠버네티스는 자동으로 포드를 스케줄링하고 리소스를 할당하므로, 컨테이너에 대한 CPU 및 메모리 사용량을 제한하는 설정이 필수적입니다. 이를 통해 리소스 고갈을 방지하고, 다른 애플리케이션에 영향을 미치지 않도록 할 수 있습니다.<br/>
    ```yaml
    resources:
      limits:
        cpu: "500m"
        memory: "512Mi"
      requests:
        cpu: "250m"
        memory: "256Mi"
    ```
- **헬스 체크**: 쿠버네티스는 컨테이너의 상태를 지속적으로 모니터링합니다. Liveness와 Readiness 프로브를 설정해 컨테이너가 비정상 상태일 때 자동으로 재시작되도록 구성하면, 서비스 가용성을 높일 수 있습니다.<br/>
    ```yaml
    livenessProbe:
      httpGet:
        path: /health
        port: 80
      initialDelaySeconds: 5
      periodSeconds: 10
    ```
- **보안**: 네임스페이스 격리, RBAC(Role-Based Access Control) 설정을 통해 리소스 접근 권한을 제한하고, 포드 간 네트워크 정책(Network Policy)을 설정하여 불필요한 접근을 차단합니다.
- **노드 자동 확장(Auto Scaling)**: 클러스터에 리소스가 부족해질 때 자동으로 노드를 추가하는 설정을 통해 트래픽 증가에 유연하게 대응할 수 있습니다. 이를 위해 Kubernetes 클러스터 오토스케일러를 설정하는 것이 좋습니다.
<br/><br/>

### 3. ECS와 쿠버네티스 비교 및 선택 가이드
서비스에 따라 ECS와 쿠버네티스 중 어느 오케스트레이션 도구가 더 적합한지 선택할 때는 **비용**과 **확장성**을 기준으로 고려하는 것이 좋습니다.

**[비용 관점에서의 비교]**<br/>
- **ECS**<br/>
  ECS는 AWS에 최적화되어 있고, **AWS Fargate**와 함께 사용하면 서버리스로 운영할 수 있어 초기 비용을 줄일 수 있습니다. 특히, 단순한 오케스트레이션 환경이 필요하고 AWS 리소스를 주로 사용하는 경우 ECS가 비용 면에서 유리할 수 있습니다.
- **Kubernetes**<br/>
  Kubernetes는 설치와 관리 비용이 더 들지만, 다양한 클라우드 및 온프레미스 환경을 지원하므로 장기적으로 더 많은 유연성을 제공합니다. AWS EKS를 사용할 경우 EC2 인스턴스를 사용하므로 EC2 비용이 발생하며, 클러스터 오토스케일링 설정에 따라 비용이 증가할 수 있습니다.

**[확장성 관점에서의 비교]**<br/>
- **ECS**<br/>
  ECS는 AWS 내에서 확장이 용이하며, 서비스가 단일 리전에서 운영되는 경우 관리가 쉽습니다. 하지만, 멀티 클러스터나 멀티 클라우드 아키텍처가 필요할 경우 제한적일 수 있습니다.
- **Kubernetes**<br/>
  Kubernetes는 멀티 클러스터 관리와 멀티 클라우드 환경에서의 확장이 용이합니다. 다양한 클라우드와 온프레미스 환경에서 하나의 클러스터처럼 운영할 수 있어 확장성이 뛰어납니다. 복잡한 아키텍처나 글로벌 서비스가 필요할 때 Kubernetes가 더 적합한 선택이 될 수 있습니다.

**[요약]**<br/>
이와 같은 기준을 통해 서비스의 요구사항에 따라 ECS와 쿠버네티스 중 적합한 도구를 선택할 수 있습니다.

- **ECS가 적합한 경우**
    - AWS에 최적화된 단순한 오케스트레이션 환경이 필요할 때
    - 서버리스 환경(Fargate)에서 비용을 절감하고 싶을 때
- **Kubernetes가 적합한 경우**
    - 멀티 클러스터 또는 멀티 클라우드 아키텍처가 필요한 복잡한 서비스
    - 온프레미스와 클라우드를 혼합해 사용해야 하는 환경
<br/><br/><br/><br/>

# Outro
이번 글에서는 쿠버네티스로 오케스트레이션을 구현하는 방법과 주의사항, 그리고 ECS와 쿠버네티스를 비교하여 어떤 상황에 더 적합한지에 대해 다루었습니다.<br/>
쿠버네티스는 다양한 환경에서의 확장성과 유연성을 제공하고, ECS는 AWS에 최적화된 비용 효율적인 솔루션이라는 점에서 차이가 있습니다.

다음 글에서는 쿠버네티스 오케스트레이션의 자동화와 고도화 방법을 소개해 드리겠습니다.

긴 글 읽어주셔서 감사합니다. 질문이 있으시면 언제든지 댓글로 남겨주세요!