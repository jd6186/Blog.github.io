---
layout: post
title: "Serialization"
tags: [Java, Spring, Basic]
author: "DongUk"
---

## Intro
안녕하세요 Jams & Donguk의 **Donguk**입니다
Spring Boot를 실무에서 사용하다보니 Spring 기본 원리에 대해 다시 한 번 복습하는 과정이 필요할 것 같아 글을 작성하게 되었습니다.<br/>
Java를 기본적으로 사용해보신 적이 있다는 전제하에 글을 쓸 것이기 때문에 Java를 모르시는 분들에게는 친절한 글이 아닐 수 있습니다.<br/>
Spring에 대한 기본적인 내용을 간단하게 확인하면서 넘어가도록 하겠습니다.
<br/><br/><br/><br/>

## Spring 구성
스프링을 구성하는 것들 중 크게 3가지를 미리 눈에 익히시고 이후에 나오는 내용들을 보시면 이해가 쉬울 것 같습니다.<br/>
앞으로 계속 사용할 용어들이기 때문에 자연스럽게 익히실 수 있도록 자주 보여드리겠습니다.
<br/>
1. **Spring Container**
> Spring Container는 Spring Bean을 보관 및 관리하는 곳으로서 이후 나올 SpringCore가 작동하는 공간입니다.

2. **Spring Bean**
> **Spring Container에 등록되어지는 객체**들로 **Singleton Pattern**을 적용해 등록되기 때문에 Spring 실행 시 한 번만 등록된다는 특징을 가진 객체들입니다.<br/>
> *물론 객체 스스로가 그렇게 작동하는 것이 아닌 **Spring Core가 관리**하는 것입니다.*<br/>
> 내부 설정을 바꿔주면 특정 조건마다 새롭게 객체를 등록할 수는 있지만 굳이 그런 식으로 사용되는 경우는 극히 드뭅니다.

3. **Spring Core**
> Spring의 핵심 기능 3가지 <br/>
제어역전 - IOC(Inversion Of Controller)<br/>
관점지향 프로그래밍 - AOP(Aspect Oriented Programming)<br/>
이식 가능한 서비스 추상화 - PSA(Portable Service Abstraction)<br/>
위 3가지가 가능하도록 Spring Bean들을 관리하는 Spring의 Engine이라고 생각하시면 됩니다.

아마 Spring을 처음 접하시면 위 3가지에 대해 모르는 분들이 많을 텐데 위 내용이 있다는 것만 아시고 그냥 글을 쭉 읽어주시면 되겠습니다.
<br/><br/><br/><br/>

## Spring의 간단한 등장 배경
Spring은 Java위에서 실행되어 Web Service를 효과적으로 만들 수 있도록 지원하는 FrameWork입니다.
따라서 사실은 없어도 개발은 가능합니다.

실제로 Spring이 없던 시절에는 **POJO**라고 불렸던 순수자바객체(변수, Getter, Setter, Constructor로 구성된 객체)와 **JDBC Connection**을 활용해 개발을 진행했었다고 합니다.
하지만 위 방법은 단점이 많았습니다.

1. DB Connection을 구성하기 위해 너무 많은 코드를 작성
2. 쿼리 사용해 DB에 한 번 요청을 보내기 위해 너무 많은 중복 코드 작성 필요
3. MVC 구조를 만들 때 각각의 객체들을 연결하기 위해 너무 많은 객체들을 중복해서 인스턴스 해야하는 이슈 존재
4. 핵심 로직을 제외한 나머지 공통 로직을 매 기능을 제작할 때마다 수시로 작성해야하는 이슈 존재
5. 전체 Controller로 접근하는 요청들에 대해 보안기능적용, filter, intercepter등을 제작하기 어려움
6. ...

너무 많은 이슈들이 존재했습니다.
간단한 기능을 제작할 때에도 위와 같은 이슈들을 모두 고려하며 제작을 해야하는 어려움을 줄이고자 개발자들에게 봄을 가져다 준다는 **Spring**이 등장한 것입니다.
<br/><br/><br/><br/>

## Spring이 가져다준 봄
그럼 어떤 기능들이 추가되었을까요?
너무 많은 기능들이 있지만 위에 있는 내용들에 대한 답변 형식으로 크게 3가지를 설명드려보겠습니다.

#### 1. DB Connection을 구성하기 위해 너무 많은 코드를 작성
PSA(Portable Service Abstraction) 글을 쭉 읽으셨으면 한 번 지나친 개념입니다.
이 개념은 **추상화 객체를 활용해 내장된 다양한 서비스를 사용하는 것**을 의미합니다.
이게 왜 DB Connection쪽에 등장하는 개념일까요?
<br/><br/>
Java로 DB와 통신을 구현하기 위한 방법을 살펴봅시다.<br/>
**<strong style="color: #bb4177;">1) Spring 등장 이전</strong>**<br/>
> 1. DB Connection 연결
2. Transaction 시작
3. Query실행
4. Commit or Rollback
5. DB Connection 연결 종료(즉, 자원반납)

```java
public void method_name() throw Exception {
    TransactionalSynchronizationManager.initSunchronization(); // 1. DB Connection 생성
    Connection c = DataSourceUtils.getConnection(dataSource); // 2. 트랜잭션(Transaction) 시작
    try {
        // 3. DB 쿼리 실행
        c.commit(); // 4. 트랜잭션 커밋
    } catch(Exception e) {
        c.rollback(); // 5. 트랜잭션 롤백
        throw e;
    } finally {
        // 6. DB Connection 종료(자원반납)
        DatasourceUtils.releaseConnection(c, dataSource);
        TransactionSynchronizationManager.unbindResource(dataSource);
        TransactionSynchronizationManager.clearSynchronization();
    }
}
```
*DB와 연결해야되는 모든 객체는 위와 같이 작업을 해야 했습니다.*
<br/><br/>

**<strong style="color: #bb4177;">2) Spring 등장 이후</strong>**<br/>
DB연결을 하는 Spring Bean 생성 시 내가 생성하지도 않은 @Transactional이라는 Anotation을 활용할 수 있어집니다.(Spring Data JPA를 활용하면 이런 과정 조차 사라집니다.)

> 1. DB 연결 객체를 Configuration을 활용해 Spring Bean에 1회만 등록
2. 이후 원하는 곳에서 내가 만든적도 없는 @Transcational만을 선언해 Transaction관리<br/>
다만 Spring Bean으로 선언된 객체 안에서만 작동

```java
@Configuration
public class AppConfig {
      private DataSource dataSource;
      @Autowired
      public DbConnectionConfig(DataSource dataSource) {
          this.dataSource = dataSource;
      }
      @Bean
      public MemberRepository memberRepository(){
          return new JdbcTemplateMemberRepository(dataSource);
      }
}
```

```java
@Transactional
public boolean insertUser(User user){
  ...
}
```
이렇게 하나의 **추상화 객체(@Configuration으로 등록된 AppConfig Class)**를 선언함으로써 **눈에 보이지 않는 여러 기능(@Transaction)을 활용할 수 있는 것**을 **<strong style="color: #bb4177;">'PSA(Portable Service Abstraction)'</strong>**라고 부릅니다.
<br/><br/>


#### 3. MVC 구조를 만들 때 각각의 객체들을 연결하기 위해 너무 많은 객체들을 중복해서 인스턴스 해야하는 이슈 존재
Java를 해보신 분은 알겠지만 특정 Class에서 외부 Class들을 가져와 사용하기 위해서는 **<strong style="color: #bb4177;">'Instance'</strong>**라는 과정이 필요합니다.

간단하게 Service와 Repository를 연결해보겠습니다.<br/>
**<strong style="color: #bb4177;">1) Spring 등장 이전</strong>**<br/>
JdbcMemberRepository라는 Repository객체를 MemberService 객체에서 불러와 사용하기 위해서는 아래와 같이 instance를 시켜 사용할 수 있습니다.
```java
public class MemberService {
    private final JdbcMemberRepository memberRepository = new JdbcMemberRepository();

    public Long join(Member member){
        member = memberRepository.save(member);
        return member.getNo();
    }
}
```
하지만 아래와 같은 방법을 한번만 실행하는 것이 아니라 수천, 수만명이 사용하는 서비스에 적용하게 된다면 어떻게 될까요?
요청이 들어올 때 마다 **new를 통해 계속해서 Instance**를 하기 때문에 메모리 낭비가 당연히 커질 수 밖에 없어 이는 Web Service를 만들기에 적합한 방법이 아닙니다.<br/>
그렇다면 이를 **Singleton Pattern**을 활용해 하나만 Instance 후 이를 활용하는 모든 객체에서 가져다 쓸 수 있도록 팩토리 패턴을 구현한다치겠습니다. 이를 구현하기 위한 노력을 개발자들이 하는 순간 사실상 **서비스로직을 개발하는데 사용해야 하는 인적 리소스를 공통을 잡는데 뺐기는 격**이 됩니다.<br/>
이런 비효율을 막기 위해 Spring에서 제공하는 기능을 살펴보겠습니다.
<br/><br/>

**<strong style="color: #bb4177;">2) Spring 등장 이후</strong>**<br/>
Spring을 활용하면 위와 같은 리소스 낭비를 줄일 수 있습니다.
> 1. Service로 사용할 객체 위에 @Component Anotation이 내장된 @Service Anotation를 선언하여 해당 객체를 Spring Bean으로 등록
2. 이를 통해 어떤 Spring Bean에서도 접근 가능하도록 개발자의 추가적인 노력없이도 Spring 자체적으로 기능 제공
2. 만들어진 객체에서 PSA를 활용해 @Autowired Anotation을 정의
3. Spring Bean에 등록된 다른 Spring Bean 객체를 인스턴스 없이 가져와 주입

```java
@Service
public class MemberService {
    private final MemberRepository memberRepository;
    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    public Long join(Member member){
        member = memberRepository.save(member);
        return member.getNo();
    }
}
```
위 기능이 제어역전 IOC(Inversion Of Controller)라고 부르는 특성이다.
제어 역전이란 원래 개발자가 관리하던 Bean의 제어권을 Spring으로 돌림으로서 개발자의 추가적인 노력없이도 Spring에 의해 Bean이 관리되는 것을 의미한다.
이를 통해 얻을 수 있는 장점으로 대표적인 '의존성 주입(Dependency Injection)'이 있다.
// TODO
// 여기서부터 DI 설명
<br/><br/>

#### 4. 핵심 로직을 제외한 나머지 공통 로직을 매 기능을 제작할 때마다 수시로 작성해야하는 이슈 존재
// TODO
// AOP 설명

<br/><br/>
## Spring의 생애주기(Spring Life Cycle)
위에서 쭉 설명했던 Spring Bean을 활용하는 것이 웹개발에 많은 편의성을 제공한다는 것은 이제 이해하실 수 있으실 겁니다.
하지만 어떻게 이 Spring
